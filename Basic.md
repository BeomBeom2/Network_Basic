# Network_Basic



# 방화벽(in/out 바운드)

방화벽은 **네트워크를 통과하는 통신을 허용/거부/검열/수정하는 모듈**이다. 방화벽은 물리적으로 네트워크를 연결하고 절단시키는 구조를 갖고있기 때문에 응용프로그램을 고칠 필요없이 쉽게 사용할 수있고, 네트워크에 흘러다니는 모든 패킷을 검사해여 해킹과 같은 외부침입을 근본적으로 막을 수 있다. 


## 인바운드 & 아웃바운드

|인바운드		|아웃바운드                         
|---						|---
|내부를 향한다		|외부를 향한다
|서버 내부로 들어오는 것  |서버 외부로 나가는 것   
|클라이언트가 업로드 할때 | 클라이언트가 다운로드 할 때
| 자신의 컴퓨터로 들어오기 시작하는 네트워크 데이터 | 자신의 컴퓨터에서 나가기 시작하는 네트워크 데이터

- 인바운드 트래픽: 클라이언트가 서버에게 request를 보내면서 시작되는 트래픽 
- 아웃바운드 트래픽: 서버가 클라이언트에게 먼저 요청을 보내면서 시작되는 트래픽

### 인/아웃 바운드 방화벽 설정
 1. win + R , firewall.cpl 열기
 2. 윈도우 ICMP 요청 전체 허용
	네트워크 통신체크가 안될경우 파일 및 프린터 공유(에코요청 - ICMPv4-in)을 선택후 규칙사용 클릭

> 특정 네트워크 사용자에게만 허용도 설정으로 가능

## ICMP
**인터넷 제어 메세지 프로토콜(Internet Control Message Protocol)**
OST7계층 중 3계층(Network Layer)의  IP 프로토콜은 전송상태에 대한 관리가 이루어지지 않는 신뢰할 수 없는 프로토콜이다. 이러한 IP 프로토콜의 단점을 보완하기 위한 프로토콜. **IP 패킷 전송 중 에러 발생 시 에러 발생 원인을 알려주거나 네트워크 상태를 진단**해주는 기능을 제공

ICMP 프로토콜 구조 <HR>

| Type(8bits)		|Code(8bits)		| Checksum(16bits)
|-							|-							|-	

|		Restof the of the header
|-

|		Data Section
|-

ICMP 메시지는 메시지의 유형을 의미하는 Type 필드와 유형별 세부내용을 담고있는 Code 필드로 구성된다.

**- Type**  : ICMP 메시지의 유형 / 용도  
ex) Type 3 : Destination Unreachable 목적지 도달 불가
**- Code**  : Type의 세부 내용으로 Type과 Code가 조합되어 ICMP 메시지의 목적과 용도를 나타낸다. (Code가 없는 Type도 존재)
ex) Type 3 Code 3 : Port Unreachable UDP 포트가 열려있지 않음
**- Checksum**  : ICMP 메시지 오류를 검사하기 위한 값
**- Rest of the header**  : Type 과 Code 에 따라 추가되는 헤더
**- Data section**  : 데이터가 위치하는 영역

#### TTL(Time To Live)
패킷이 라우터에서 폐기되기 전에 네트워크 내에 존재하도록 설정된 시간 또는 "홉(hop-소스와 목적지 간의 경로)"를 나타낸다.

**TTL의 작동**
&nbsp;패킷이 만들어지고 인터넷으로 전송되면 라우터에서 라우터로 계속 전달될 수 있다. 이런 가능성을 줄이기 위해 패킷은  Time-To-Live 또는 hop limit이라는 만료 시간으로 설계된다.
&nbsp;패킷 TTL은 패킷이 순환되는 시간을 결정하는 데 유용 할 수 있으며 보낸 사람이 인터넷을 통해 패킷의 경로에 대한 정보를 수신할 수 있게 한다. 
패킷에는 네트워크를 통해 이동 해야 하는 시간을 결정하는 숫자 값을 저장하는 장소가 있다. 라우터는 패킷을 수신 할 때마다 TTL 수에서 하나를 뺀 다음 네트워크의 다음 위치로 전달합니다. TTL의 카운터가 0이되면 라우터는 패킷을 버리고 ICMP 메시지 를 원래의 호스트로 되돌려 보냅니다 .


**노드(Node) : 네트워크에 연결된 모든 종류의 장치**

**호스트 : 네트워크 주소(IP 주소)가 할당된 노드** `(인터넷에 연결되어 있으면 호스트라고 부를 수 있다)`
네트워크에 연결된 스마트폰이든 데스크든 노트북이든 호스트들끼리 서로 데이터를 주고받는다.

**데이터를 주고받는 것은 호스트 내 프로세스다**

**프로그램, 애플리케이션, 앱, 소프트웨어를 모두 프로세스라는 용어로 통일하겠다. 한 컴퓨터나 스마트폰 내에는 여러 개의 프로세스들이 존재하며 이 프로세스들은 동시에 혹은 마치 동시라고 느껴지게끔 동작한다.** 예를 들어볼까? 음악을 들으면서 인터넷을 하거나, 게임을 하면서 영화를 다운로드하는 것 등 등이 한 호스트에서 동시에 여러 프로세스들이 동작하는 예이다. 지금 여러분도 이 글 보면서 동시에 음악을 듣고 있을 지도 모른다. 

**네트워크에서 데이터를 주고받는다는 것은,  호스트 프로세스까지 데이터가 오고 감을 의미한다.**

상상해보자. 카톡을 통해 전송한 메시지는 당연히 보안이 유지돼야 한다. 상대방의 카톡에 도착해야 한다. 친구가 인스타그램에 맛집 사진을 올렸다면, 내 스마트폰의 페이스북이 아니라 인스타그램에서 해당 사진이 보여야 한다. **이처럼 데이터를 주고받는 것은 호스트의 프로세스 레벨까지 일어나는 일이다.**



**소켓(Socket)과 포트(Port)**


_**'데이터는 프로세스 레벨에서**_ _**주고받는다'**_라는 것을 이해했고, _**'호스트에서는 여러 프로세스가 동시에 동작한다'**_라는 것을 이해했다면, _**'데이터가 네트워크를 타고 목적지 호스트에 도착했다고 끝이 아니라, 그 호스트에서 동작하는 여러 프로세스 중에 실제로 이 데이터를 받아야 하는 프로세스까지 전달되야 한다'**_라는 것도 이해했을 것이다. **이를 위해 포트가 등장한다.**

​
**포트(Port)는, 네트워크를 통해 데이터를 주고받는 프로세스를 식별하기 위해 호스트 내부적으로 프로세스가 할당받는 고유한 값이다.**


이 값은 숫자로 표현되기 때문에, **포트 넘버(Port number)**라고도 한다. 데이터를 담고 있는 편지봉투에 목적지의 포트가 28080으로 적혀있다면, 목적지 호스트에 도착한 뒤에 해당 호스트에서 28080 포트를 할당받은 프로세스를 찾아서 데이터를 전달해야 한다.

​
**그럼 포트는 데이터를 받기 위해서'만' 필요한 걸까?**  **노노노~!! 그렇지 않다. 데이터를 보내는 호스트의 프로세스도 반드시 보내기 전에 포트 번호를 할당받아서 보내야 한다.** 만약 데이터를 요청하는 호스트가 발신인 불명으로 요청을 보내면 어떻게 될까? 요청받은 호스트의 프로세스가 봉투를 받았는데, 봉투에 발신인이 없다;; 요청한 내용을 처리해서 보내주고 싶어도, 어디로 보내줘야 할지 모른다. 이런 불상사를 막기 위해, 데이터를 보내는 프로세스도 반드시 포트 넘버를 할당받아야 한다.

오오 신박하다! 재밌다!! 뭔가 말 된다!!! **그럼 소켓은 뭘까?**


**소켓(Socket)은, 프로세스가 네트워크를 통해서 데이터를 주고받으려면 반드시 열어야 하는 창구 같은 것이다.**


**컴퓨터 세계관에서는 프로세스가 데이터를 보내고 싶다고 해서 막 보낼 수 있는 게 아니고, 그들만의 법칙이 있는데, 바로 보내는 쪽도 받는 쪽도 소켓을 열어야 한다는 점이다.** 보내는 쪽이 소켓이라는 창구를 열고 소켓을 통해서 데이터를 보내면 네트워크 모델에 따라 목적지 호스트에 데이터가 도착하게 되고, 데이터를 담은 봉투에 써진 도착지의 포트 넘버와 같은 포트를 할당받은 프로세스를 찾아서, 그 프로세스의 소켓을 통해 해당 프로세스에 데이터를 전달한다.

​
**소켓을 열기 위해선 호스트에 할당된 IP 주소, 포트 넘버, 프로토콜(Protocol) 등이 필요하며, 이 세 가지가 소켓을 정의한다.** 프로토콜은 통신 방법? 규약? 같은 건데, 일단 패스하자.

----------

**소켓과 포트는 다르다!**

프로세스가 네트워크 통신을 하기 위해서는 포트를 할당받아야 하는데, [**서버**](https://blog.naver.com/myca11/221369799273)의 경우에는 보통 하나만 할당받는다. **왜냐하면 같은 프로세스가 같은 포트를 가지고도 여러 개의 소켓을 열 수 있기 때문이다.** 요게 매우 중요하다. 나도 이것을 헷갈려 했었다.

**흥미롭게도 하나의 프로세스는 같은 프로토콜, 같은 IP 주소, 같은 포트 넘버를 가지는 수십 혹은 수만 개의 소켓을 가질 수 있다.**

이런 이유 때문에 하나의 프로세스는 하나의 포트만으로도 다른 여러 호스트에 있는 프로세스의 요청을 처리할 수 있고, 게임 서버의 동시 접속자 수가 수십수백만이 될 수 있는 것이다.

​
**소켓을 정의하는 것과 소켓을 식별하는 것을 구분하자. IP 주소, 포트 넘버, 프로토콜로 소켓을 정의할 수 있지만, 이것이 소켓을 유일하게 식별하진 않는다.** 이름이 홍길동이라고 해도 여러 홍길동이 있는 것처럼, 같은 IP 주소, 포트 넘버, 프로토콜을 가지는 소켓이라고 해도, 서로 다른 소켓이 존재하는 것이다.

----------

후아~ 모든 이야기가 끝이 났다. 소켓과 포트의 차이가 이제는 좀 이해가 될까? 정리하면 이렇다.

> 포트(Port)는 네트워크 상에서 통신하기 위해서 호스트 내부적으로 프로세스가 할당받아야 하는 고유한 숫자이다. 한 호스트 내에서 네트워크 통신을 하고 있는 프로세스를 식별하기 위해 사용되는 값이므로, 기본적으로는 같은 호스트 내에서 서로 다른 프로세스가 같은 포트 넘버를 가질 수 없다. (방법이 있긴 하다.)

> 소켓(Socket)은 프로세스가 드넓은 네트워크 세계로 데이터를 내보내거나 혹은 그 세계로부터 데이터를 받기 위한 실제적인 창구 역할을 한다. 그러므로 프로세스가 데이터를 보내거나 받기 위해서는 반드시 소켓을 열어서 소켓에 데이터를 써보내거나 소켓으로부터 데이터를 읽어들여야 한다.

> 소켓은(Socket)은 프로토콜, IP 주소, 포트 넘버로 정의된다.

[소켓(Socket) 포트(Port) 뜻과 차이](http://blog.naver.com/myca11/221389847130)

같은 포트 ip 주소, protocol에 대해서 여러 개의 소켓이 존재할 수 있지만, 연결(connection)을 맺기 전에 요청을 기다리는 Listening 상태는 오직 한 socket만 존재할 수 있습니다. 그렇기 때문에 처음 연결을 요청하는 데이터는 단 하나의 Listening 상태인 소켓으로 갈 수 있는 것이죠.  
  
  C1. 오늘 설명한 것이, 사실 네트워크 세계관에서 [**OSI 모델**](https://en.wikipedia.org/wiki/OSI_model)의 [**전송 계층(Transport layer)**](https://en.wikipedia.org/wiki/Transport_layer)를 설명한 것이다.


C2. **위에서 말한 프로토콜은 전송 계층에서 사용하는 프로토콜 들을 의미**한다. 대표적으로 [**TCP**](https://en.wikipedia.org/wiki/Transmission_Control_Protocol), [**UDP**](https://en.wikipedia.org/wiki/User_Datagram_Protocol)가 있다.


C3. 편지 봉투에 포트 넘버가 쓰여있다고 비유를 들어 설명했는데, **실제 전송 계층에서는 이 편지 봉투 비유가 프로토콜의 헤더(Header)를 의미**한다. 즉, [**TCP 헤더**](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure) 혹은 [**UDP 헤더**](https://en.wikipedia.org/wiki/User_Datagram_Protocol#Packet_structure)를 의미한다.

**C4. 엇? 이상하다? 그러면 같은 프로세스에 대해서 같은 프로토콜, 같은 IP 주소, 같은 포트 넘버를 가질 수 있다면, 데이터가 도착했을 때 어떤 소켓으로 가야 하는지 어떻게 알까?? 궁금하지 아니한가??**

연결이 확립된 이후의 데이터를 받는 경우에는, socket식별을 연결(connection) 정보로 합니다. 즉, 데이터를 보낸 쪽의 ip 주소와 포트 넘버, 데이터를 받는 쪽의 ip 주소와 포트 넘버를 활용해서 어느 소켓으로 데이터가 가야할 지를 식별할 수 있는 것이죠.


# URI

Uniform Resource Identifier. resource의 식별자. 리소스의 식별은 리소스의 위치를 표시하거나 unique한 이름으로 접근할 수 있을 것이다. 현실 세계에 비유하면, 나를 내 거주지(위치)나 나의 주민등록번호로 다른 사람과 나를 구별할 수 있는 객관적인 방법이 생기는 것이다.

# URL

Uniform Resource Locator. resource를 access할 수 있는 위치를 나타낸다.

## 구성

protocol(necessary) + domain name(necessary) + port + path to the file + parameters + anchor

**설명**

-   protocol은 네트워크 상에서 브라우저가 데이터를 주고 받기 위한 통신 규약이다.
-   domain name은 request를 보내려는 웹서버를 나타낸다. 본래 IP 주소를 사용하였으나 숫자를 외우기에는 인간에게 상당히 불편하였다. 따라서 domain name을 문자열로 정하고 이를 관련된 ip address로 바꿔주는 dns가 등장하였다.
-   port는 웹서버에서 리소스를 얻기 위해 어떤 gate를 사용해야 하는지 명시한다. http는 표준 포트는 80번, https 표준 포트는 443번인데 웹서버가 프로토콜의 표준 포트를 사용한다면 url에서 port는 버려진다.
-   path는 web server의 리소스 경로이다. 옛날에는 실제로 웹서버 상에 파일의 경로를 url의 path 근래에 와서는 거의 web server에서 file이 위치하는 물리적 경로를 사용하지 않고 추상화된 경로를 사용한다.
-   anchor가 명시되면 페이지를 로드할 때 html document에서 해당 anchor가 정의된 곳으로 이동한다.

## 예시

-   예시
    
    > [https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn](https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn)
    

예시의 url 구성

-   https protocol: https://
-   domain name: stackoverflow.com
-   path to the file: /questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn

# URN

Unifrom Resource Name. resource의 name을 나타낸다.  
예시로는 ISBN 시스템이 있다. URL과 같이 access할 수 있는 위치가 아닌 이름으로 표시된다.

예시: ISBN 0-486-27557-4

# URL, URI와 URN의 관계

URL과 URN은 URI의 부분집합이다. rfc 규칙들 중에서 모든 url을 uri로 인정하지 않는 규칙도 있으나 통상적으로 모든 url을 uri로 인정한다.


## SSL: 보안 소켓 계층(Secure Sockets Layer, SSL)

SSL은 **웹사이트와 브라우저(혹은, 두 서버) 사이에 전송된 데이터를 암호화하여 인터넷 연결을 보안을 유지**하는 표준 기술입니다. 이는 해커가 개인 정보 및 금융 정보를 포함한 전송되는 모든 정보를 열람하거나 훔치는 것을 방지합니다.

## TLS: 전송 계층 보안(Transport Layer Security, TLS)  

TLS는 **가장 최신 기술로 더 강력한 버전의 SSL**입니다. 그러나 SSL이 더 일반적으로 사용되는 용어이기에, 여전히 보안 인증서는 SSL이라 불립니다.


## HTTPS: 하이퍼 텍스트 프로토콜 보안(Hyper Text Protocol Secure, HTTPS)

HTTPS는 웹사이트를 SSL/TLS 인증서로 보안하는 경우 URL 창에 표시됩니다. 사용자는 브라우저 바의 잠금 기호를 클릭하여 인증서 발행, 웹사이트 소유 기업명을 포함한 인증서의 세부 내용을 확인할 수 있습니다.

## SIP 프로토콜

“세션 개시 프로토콜(Session Initiation Protocol, **SIP**)”이란 IETF에서 정의한 시그널링 프로토콜로 음성과 화상 통화 같은 멀티미디어 세션을  제어하기 위해서 많이 사용되었으며, **인터넷 상에서 통신하고자 하는 지능형 단말(전화, 인터넷 콘퍼런스, 인스턴트 메신져 등)들이 서로 식별하여 그 위치를 찾고, 그들 상호 간에 멀티미디어 통신 세션을 생성하거나 삭제 또는 수정하기 위한 절차**이며 명시한 응용 계층의 시그널링 프로토콜입니다.  
수정은 포트의 주소 변경과 더 많은 참여자의 초대, 멀티미디어 스트림의 추가 또는 삭제를 의미하고 있습니다. 화상 회의, 스트리밍 동영상 유통, 메신저, 가입 상태 정보, 파일 전송과 더불어서 온라인 게임에 응용할 수 있습니다.


### Http통신과 Socket 통신의 차이

**1. Http 통신**
	Cient의 요청(Request)이 있을 때만 서버가 응답(Response)하여 해당 정보를 전송하고 곧바고 연결을 종료하는 방식
	
-   Client가 요청을 보내는 경우에만 Server가 응답하는 단방향 통신이다.
-   Server로부터 응답을 받은 후에는 연결이 바로 종료된다.
-   실시간 연결이 아니고, 필요한 경우에만 Server로 요청을 보내는 상황에 유용하다.
-   요청을 보내 Server의 응답을 기다리는 어플리케이션(Android or Ios)의 개발에 주로 사용된다

**2. Socket 통신**
	**Server와 CLient가 특정 Port를 통해 실시간으로 양방향 통신을 하는 방식**

-   Server와 Client가 계속 연결을 유지하는 양방향 통신이다.
-   Server와 Client가 실시간으로 데이터를 주고받는 상황이 필요한 경우에 사용된다.
-   실시간 동영상 Streaming이나 온라인 게임 등과 같은 경우에 자주 사용된다.

**3. FTP 통신**
	FTP는 TCP/IP 프로토콜을 통해 서버와 클라이언트 간에 파일을 전송하기 위한 프로토콜이다.
&nbsp;즉 네트워크에 연결된 컴퓨터끼리 데이터를 원활하게 교환하기 위한 목적으로 개발

FTPS: FTP 프로토콜과 TLS 프로토콜이 결합한 형태
SFTP: FTP 프로토콜과 SSH 프로토콜이 결합한 형태

 FTP에는 제어 채널과 전송 채널이 있다. 전송 채널은  20번(FTP-data-port) 포트를 사용하고 제어 채널은 21번(FTP-port) 포트를 사용한다. FPT는 다른 서비스들과는 다르게 Active mode와 Passive mode가 존재한다.

   **- FTP Active Mode 동작 방식**

![active mode](https://user-images.githubusercontent.com/62642155/106144006-ee9ada00-61b6-11eb-85b5-e9d2f124d543.png)

(1) 클라이언트가 서버의 command(21번) 포트로 접속
(2) 서버 -> 클라이언트 ACK
(3) 서버는 data(20번) 포트를 이용해 클라이언트로 접속
(4) 클라이언트 -> 서버 ACK

  
**문제점** 
- 보통의 TCP/IP는 클라이언트가 서버에 접속을 시도하는 반면 Active mode의 FTP는
##### 반대로 서버가 클라이언트에 접속을 시도하기 때문에 클라이언트의 네트워크로 접속이 허용되어 있지 않다면(방화벽 등) 3번째 이후의 작업이 진행되지 않아 FTP 접속은 되지만 데이터 목록을 받아오지 못하는 에러가 발생한다.

- Active mode의 제어 채널: 클라이언트 -> 서버:21번 포트
- Active mode의 전송 채널: 서버:20번 포트 -> 클라이언트

   **- FTP Passive Mode 동작 방식**
   
![passive mode](https://user-images.githubusercontent.com/62642155/106144050-ff4b5000-61b6-11eb-9779-9992d7199d07.png)


(1) 클라이언트가 서버의 command(21번) 포트로 접속
(2) 서버 -> 클라이언트 ACK / data(3267번) 포트를 알려줌
(3) 클라이언트는 data(3267번) 포트를 이용해 서버로 접속
(4) 서버 -> 클라이언트 ACK

**문제점**
- 두번째 data 포트를 20번을 사용하지 않고 동적 포트(1024번 이후)를 랜덤으로 사용한다.

##### 따라서 이를 이용하면 Active 모드의 문제점은 해결이 되지만 서버의 동적 포트를 전부 열어두어야 하는 보안상의 문제점이 발생한다.

- Passive mode의 제어 채널: 클라이언트 -> 서버:21번 포트
- Passive mode의 전송 채널: 클라이언트 -> 서버:임의의 포트


## SSH(Secure Shell)

**네트워크 프로토콜** 중 하나로서 컴퓨터와 컴퓨터가 인터넷과 같은 Public Network를 통해 서로 통신을 할 때 보안적으로 안전하게 통신을 하기 위해 사용하는 프로토콜.
&nbsp;기존의 유닉스 시스템 셸에 원격 접속하기 위해 사용하던 텔넷은 암호화가 이루어지지 않아 계정 정보가 탈취될 위험이 높으므로, 여기에 암호화 기능을 추가하여 1995년에 나온 프로토콜(SSH는 암호화 기법을 사용하기 때문에, 통신이 노출된다고 하더라도 이해할 수 없는 암호화된 문자로 보인다.)

```복호화(復號化)또는 디코딩(decoding, 해독)은 Encoding(부호화)된 데이터를 Code(부호)화 되기 전 형태로 바꾸는 것. Encryption(암호화)의 반대말로서의 Decryption(복호화)라고 부른다. 영어로는 Decoding과 Decryption이 구분되지만 한국어로는 구분되지 않는다.```

### 주요 기능

-   보안 접속을 통한 rsh, rcp, rlogin, rexec, telnet, ftp 등을 제공.
-   IP spoofing (IP스푸핑, 아이피 위/변조 기법중 하나)을 방지하기 위한 기능을 제공.
-   X11 패킷 포워딩 및 일반적인 TCP/IP 패킷 포워딩을 제공.

### 공개키 암호화(데이터 보안 중점)

![데이터 보안 중점 공개키 암호화](https://user-images.githubusercontent.com/62642155/106878569-746dd680-671d-11eb-9472-a35058a26020.jpg)


### 개인키 암호화(전자서명)

![전자서명 개인키 암호화](https://user-images.githubusercontent.com/62642155/106878641-851e4c80-671d-11eb-8bde-cc36ccbc1b62.jpg)


### Private Key and Public Key

SSH는 통신을 하기 위해 접속을 할 때 우리가 일반적으로 사용하는 비밀번호의 입력을 통한 접속을 하지 않는다.
기본적으로 SSH는 한 쌍의 Key를 통해 접속하려는 컴퓨터와 인증 과정을 거치게 된다. 이 한 쌍의 Key는 Private Key,  Public Key로 이루어져 있다 

####  - Public Key
 단어 뜻 그대로 공개되어도 비교적 안전한 Key.
  이 Public Key를 통해 메시지를 전송하기 전 암호화를 한다. Public Key로는 암호화는 가능하지만 복호화는 불가능하다.

 #### - Private Key
 절대로 외부에 노출이 되어서는 안되는 Key로 본인의 컴퓨터 내부에 저장하게 된다. 이 Private Key를 통해 암호화된 메시지를 복호화 할 수 있다.

이렇게 한 쌍의 Public Key와 Private Key는 서로 매우 복잡한 수학적인 관계를 맺고 있다.

이러한 Private Key와 Public Key를 통해 다른 컴퓨터와 통신을 하기 위해서 먼저 Public Key를 통신하려는 컴퓨터에 복사하여 저장한다. 그리고 요청을 보내는 클라이언트에서 접속 요청을 할 때, 응답을 하는 서버 사이드 컴퓨터에 복사되어 저장된 Public Key와 클라이언트 에 해당 Public Key와 쌍을 이루는 Private Key와 비교를 하여 서로 한 쌍의 Key인지 아닌지를 검사합니다.

이렇게 서로 관계를 맺고 있는 Key라는 것이 증명이 되면 두 컴퓨터 사이에 암호화된 채널이 형성이 되어 Key를 활용해 메시지를 암호화하고 복호화하며 데이터를 주고 받을 수 있게 됩니다.

### SSH 키 교환 방식 인증 알고리즘

  1. 클라이언트에서 SSH-keygen을 이용해, 공개 키(Public Key)와 개인 키(Private Key)를 생성한다.
  2. Secure Copy를 이용하여 클라이언트의 공개 키를 원격 서버(Remote Server)에 전송한다.
  3. 클라이언트가 원격 서버에 접속을 요청한다.
  4. 서버는 임의의 문자열을 생성해, 이를 클라이언트의 공개 키로 암호화(Encryption)하여 클라이언트에게 전송한다.
  5. 클라이언트는 전송 받은 암호화 된 문자열을 자신의 개인 키로 복호화(Decryptuion)한다.
  6. 원격 서버와 클라이언트는 동일한 문자열을 가지게 된다.
  7. 원격 서버와 클라이언트는 해시(Hash)함수를 이용해 문자열을 바탕으로 해시 값을 구한다.
  8. 클라이언트는 원격 서버에 해시 값을 전송하고, 원격 서버는 클라이언트가 보낸 해시 값과 자신의 해시 값을 비교한다,
  9. 원격 서버의 해시 값과 클라이언트의 해시 값이 동일하면, 인증(Authentication)이 완료되었다고 판단한다.
  10.원격 서버는 클라이언트의 접속 요청을 허락한다. 클라이언트는 원격 서버에 성공적으로 접속한다,

[알고리즘 출처](https://blog.naver.com/pxkey/221269433630)

[포트 포워딩](https://lamanus.kr/59)

